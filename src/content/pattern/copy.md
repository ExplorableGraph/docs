---
title: Copy a graph
set = node_modules/pattern-intro/src/set:
---

A key benefit of building a site as a graph is that we can seamlessly move between browsing that graph and rendering that graph as static content.

## Build process

When working with graphs, the "build" process can be conceptually simple:

<figure>
  Real markdown files → Virtual HTML files → Real HTML files
</figure>

1. We define a graph of the source markdown content — as an object, as real files, or as values generated by a function.
1. We use one or more transforms to create a virtual graph of the final content that we want — here, HTML. We can directly serve and browse this virtual graph during development.
1. We want to copy the virtual graph of HTML pages into some persistent form such as real `.html` files. We can then deploy these files.

For the last step, we could write the files out directly using a file system API. But we've gained a lot by abstracting away the file system read operations; we can make similar gains by abstracting away the file system write operations too.

## Setting graph values

Let's extend our Explorable interface with an optional method `set(key, value)`. This updates the graph so that getting the corresponding `key` will now return the new `value`. We can supporting deleting a key/value from the graph by declaring that, if `value` is undefined, the key and its corresponding value will be removed from the graph.

This is straightforward for our object-based graph:

```js
// Inside src/set/ObjectGraph.js
  async set(key, value) {
    if (value === undefined) {
      delete this.obj[key];
    } else {
      this.obj[key] = value;
    }
  }
```

And a fair bit of work for our file system-based graph:

```js
// Inside src/set/FilesGraph.js

  async set(key, value) {
    // Where are we going to write this value?
    const destPath = path.resolve(this.dirname, key ?? "");

    if (value === undefined) {
      // Delete the file or directory.
      let stats;
      try {
        stats = await stat(destPath);
      } catch (/** @type {any} */ error) {
        if (error.code === "ENOENT" /* File not found */) {
          return;
        }
        throw error;
      }
      if (stats.isDirectory()) {
        // Delete directory.
        await fs.rm(destPath, { recursive: true });
      } else if (stats) {
        // Delete file.
        await fs.unlink(destPath);
      }
    }

    const isExplorable =
      typeof value?.[Symbol.asyncIterator] === "function" &&
      typeof value?.get === "function";

    if (isExplorable) {
      // Write out the contents of the value graph to the destination.
      const destGraph = key === undefined ? this : new FilesGraph(destPath);
      for await (const subKey of value) {
        const subValue = await value.get(subKey);
        await destGraph.set(subKey, subValue);
      }
    } else {
      // Ensure this directory exists.
      await fs.mkdir(this.dirname, { recursive: true });
      // Write out the value as the contents of a file.
      await fs.writeFile(destPath, value);
    }
  }
```

Half the work here involves handling the case where we want to delete a file or subfolder by passing in an `undefined` value.

The other complex case we handle is when the value itself is explorable, and we have to recursively write out that value as a set of files or folders. We didn't have to handle that case specially for `ObjectGraph`, as it's perfectly fine for an `ObjectGraph` instance to have a value which is an explorable graph.

The file system is not so flexible. The good news is that all this complexity can live inside of the `FilesGraph` class — from the outside, we can just call `set` and trust that the file system will be updated as expected.

This leads to another way to think about explorable graphs: explorable graphs are software adapters or drivers for any real or virtual hierarchical storage.

## setDeep

We can now introduce a new helper function, `setDeep(target, source)`, which handles the general case of writing values from the `source` graph into the `target` graph.

```{{'js'}}
/* src/set/setDeep.js */

{{ set/setDeep.js }}
```

## Build real files from virtual content

We're now ready to build real static files for our site by copying the virtual graph of HTML pages into a real file system folder. All we need to do is wrap a real folder called `distFiles` in a `FilesGraph`:

```{{'js'}}
/* src/set/distFiles.js */

{{ set/distFiles.js }}
```

And then create a `build.js` utility that copies the virtual graph defined in `siteGraph.js` into that real `dist` folder:

```{{'js'}}
/* src/set/build.js */

{{ set/build.js }}
```

<span class="tutorialStep"></span> Use this new `build` tool from inside the `src/set` directory to copy the virtual graph into files. The `set` method for `FilesGraph` takes care to create the target directory (`dist`), so it's fine if that directory doesn't exist when we start.

```console
$ cd ../set
$ ls dist
ls: dist: No such file or directory
$ node build
$ ls dist
Alice.html Bob.html   Carol.html index.html more
```

<span class="tutorialStep"></span> Inspect the individual files in the `dist` folder to confirm their contents — or use our `json` utility to dump the entire `dist` folder to the console.

```console
$ node json distFiles.js
{{ json set/htmlObject }}
```

We can see that we've generated HTML pages for all the markdown content, and also see that each level of this tree has an `index.html` page.

## Browse the built HTML files

You could now deploy the HTML files in the `dist` folder anywhere, such as a CDN (Content Delivery Network).

<span class="tutorialStep"></span> As a quick test, serve the `dist` folder with any static server, such as [http-server](https://github.com/http-party/http-server).

```console
$ npx http-server dist
Starting up http-server, serving dist
```

(You could also temporarily hack `serve.js` to serve the graph defined by `distFiles.js` instead of `siteGraph.js`. Everything here's a graph, any you can serve any of those graphs the same way.)

<span class="tutorialStep"></span> Browse to the static server and confirm that the static results are the same as what you can see running the dynamically-generated graph.

The results will look identical, but a key difference is that no real work is necessary to display the HTML files served from the `dist` folder.

In this tutorial, the markdown-to-HTML translation happens almost instantly, but in real projects, the data or transformations could easily take some time. Viewing an individual page might require non-trivial work, resulting in a perceptible delay before the page appears. Building the pages into static files performs all the work at once, so your users can browse the resulting static files as fast as the web can deliver them.

We've now solved our original problem: we've created a system in which our team can write content for our web site using markdown, and end up with HTML pages we can deploy.

&nbsp;

Next: [Combine graphs](combine.html) »
