---
title: Virtual content
numberHeadings: true
intro = client/samples/frameworkIntro:
# Mocks for the code samples below
files:
  src: |
    "+.yaml": |
      # Origami formulas for the About Us web site.
      message: Hello, world!
virtual:
  src = graphVirtual(files/src):
---

A key concept in the Graph Origami framework is _virtual_ content: things that are generated by code but which you can browse and work with just like real content.

## Define virtual content in a YAML file

<span class="tutorialStep"></span> Inside the `src` folder, create a file called `+.yaml`.

The name of the `+.yaml` is a signal to the Origami framework that anything inside the file should be considered a virtual member of the containing folder. You can rename that file anything that starts with a plus sign, like `+formulas.yaml`.

This `+.yaml` file could also be a JSON file, but we'll use a YAML file for this tutorial because it'll be more concise.

Any keys you define in this file will appear as the name of a virtual file in the containing `src` folder. You can think of this file as something like a spreadsheet, only instead of defining and manipulating numbers, you can use this file to define and manipulate data, files, and other content.

## Define a virtual value

As an example of a simple virtual value, let's define the title of your site as a virtual value that can be referenced on all the pages.

<span class="tutorialStep"></span> Add a line to the `+.yaml` file:

```{{'yaml'}}
{{ intro/siteInitial.yaml }}
```

The line you've just added defines a key called `siteName` with a value of "Our Amazing Team". Because that key/value definition is sitting in the `+.yaml` file, the Graph Origami framework treats that value as a virtual file in the containing `src` folder when that folder is viewed in the browser (or through other means, such as a command terminal).

<span class="tutorialStep"></span> Without needing to do anything else, in the browser pane/window showing your served site, navigate to the `src` folder.

You will see a listing that includes an entry for `siteName`.

<span class="tutorialStep"></span> Click on the `siteName` link to navigate to a page that says "Our Amazing Team".

By adding an entry to a data file, you've created a virtual file that is visible via the Graph Origami server.

You don't have to use the Graph Origami server: you can integrate the support for formulas into other servers (e.g., [Express](http://expressjs.com/)). Later in this tutorial you'll dispense with a live server altogether by building static files that you can host anywhere.

## Conceptualize real and virtual files as graphs

In addition to viewing a virtual file in the served site as you did above, at any time you can also view a virtual file in the command line with the command-line tool, ori.

<span class="tutorialStep"></span> In the terminal, press Ctrl+C to stop the running server, then:

```console assert: true, path: files
$ ls src
+.yaml
$ ori src
"+.yaml": |
  # Origami formulas for the About Us web site.
  siteName: Our Amazing Team
```

(Reminder: if running locally, you'll need to use `npx ori` whenever invoking the ori tool.)

If you ask ori to render the `src` folder, it returns a graph of the real files in the `src` folder. It displays this graph in YAML form. At the moment, there is just one file called `+.yaml` that defines a key called `siteName`.

You can visualize the real files in the `src` folder as a graph:

<figure>
  {{ svg files/src }}
  <figcaption>The src folder graph has one real file</figcaption>
</figure>

If you ask ori to show the contents of a _virtual_ graph based on `src`, the resulting virtual graph includes the real files and any virtual files you've defined. The virtual graph omits special files like `+.yaml`.

<span class="tutorialStep"></span> View the virtual files:

```console assert: true, path: files
$ ori virtual/src
{{ yaml virtual/src }}
```

The `virtual` graph has a virtual `siteName` file that contains "Our Amazing Team"

<figure>
  {{ svg virtual/src }}
  <figcaption>Virtual graph includes the virtual siteName file</figcaption>
</figure>

The `src` files graph above is your starting point: the real files you create by transcribing the ideas and information in your head or collecting data from elsewhere. Through step-by-step transformations, you create a final `virtual` graph that represents the artifact you wish your audience to view or use.

_Transforming graphs is the fundamental operation of the Origami framework._

The ori command-line interface knows how to traverse graphs, including virtual graphs.

<span class="tutorialStep"></span> Ask ori to display a single virtual file on demand:

```console assert: true, path: files
$ ori virtual/src/siteName
Our Amazing Team
```

In the steps that follow, you will define Origami formulas to dynamically create data and HTML pages. At any point you can view those in the browser, or use ori to view those virtual files in the command line.

Origami lets you create virtual folders and files using formulas.

## Define a formula in a YAML key

Origami lets you define virtual values by defining formulas in the _key_ of a key/value pair.

<span class="tutorialStep"></span> Update the `+.yaml` file to include the new line shown below:

```{{'yaml'}}
{{ intro/siteFormula.yaml }}
```

Note the final `:` at the end of that line. You're defining a new _key_ in the YAML file that contains the whole formula. That key is everything before the colon. The value is whatever after the colon — in this case, no value is given, so the value is `null`. The virtual value we ultimately want is going to be defined by evaluating the formula.

In this case, the formula is trivial, and defines `greeting` as an alias for `message`.

<span class="tutorialStep"></span> View the contents of this virtual `greeting` value in the command line:

```console
$ ori virtual/src/greeting
Hello, world!
```

<span class="tutorialStep"></span> Restart the server:

```console
$ ori serve
```

You can now view the virtual `greeting` value in the `src` folder. Text next to `greeting` in gray indicates this is a virtual file generated by the above formula.

This is a trivial example of a formula; let's try something more interesting.

## Invoke a JavaScript function from a formula

If you don't consider yourself a JavaScript programmer, don't worry, JavaScript isn't necessary to build this particular site, or required to use Origami in general. We'll just use it here as just an example of how data might be transformed with regular JavaScript.

<span class="tutorialStep"></span> In the `src` folder, create a JavaScript file called `greet.js` and paste in the following:

```{{'js'}}
{{ intro/greet.js }}
```

You can use this `greet` formula in an Origami function to generate the contents of a virtual file.

<span class="tutorialStep"></span> Add the following line to the `+.yaml` file:

```yaml
index.html = greet('world'):
```

Be sure to use single quotes, not double quotes. And again note the final colon — everything to the left of that colon is a YAML key.

This formula defines a virtual file called `index.html`. The value or contents of that virtual file will be the result of evaluating the expression `greet('world')`. In this case, the reference to `greet` will obtain the function exported by `greet.js`, then invoke that function.

<span class="tutorialStep"></span> Navigate to the `src` route, which will now show an entry for `index.html`. Open that page to see "Hello, <em>world</em>!".

Each time you ask for `index.html`, the web server evaluates the corresponding formula that invokes `greet`. (If you're running this tutorial locally, you can verify this by setting a breakpoint within the greet function, then visiting `index.html`.)

Since the `greet` function is regular JavaScript, you can use that JavaScript to create HTML by any means you like. If the function is asynchronous, Origami will `await` the result before serving it to the browser. With that, you should be able to do essentially anything you want in the JavaScript function to create any HTML result.

A function like `greet` here transforms data from one form into another — in this case, it transforms a string name to an HTML greeting. The function and the file name formula that invokes it could just as easily transform other kinds of data; there's nothing special about text here.

You've seen how a formula can transform a single piece of data like a single person's name into some other form like a greeting. If you wanted to create virtual greetings for multiple people, you could create a formula for each of them. But you can also write a formula that transforms a bunch of things at once.

## Transform a graph

Let's apply the `greet` function to the entire set of people on the team. As a reminder, we can visualize the people in `team.yaml` as a graph:

<figure>
{{ svg team.yaml }}
</figure>

In Origami, a graph like this is a first-class data type that can be passed to Origami expressions or JavaScript functions. A graph can be an in-memory object, a folder tree, data in a file, dynamically-generated data, and other forms. (If you're interested, you can read more about the different [graph variants](/core/variants.html) supported by Origami.)

<span class="tutorialStep"></span> In the `+.yaml` file, add the following line:

```yaml
greetings = map(team.yaml, =greet(name)):
```

The earlier lines each defined a single virtual file like `message` or `index.html`. The `greetings` formula here defines a virtual _graph_ of things — a virtual folder of virtual files.

<span class="tutorialStep"></span> View the `src` folder in the served site. (If using StackBlitz, you can refresh the pane showing the site by clicking the small Refresh icon above that pane.)

You will see a new entry for a virtual `greetings` folder. If you click on that `greetings` folder, you'll see a list of links labeled with the indices of the array: 0, 1, 2, (and more if you entered more names). Clicking an index will take you to a page like `src/greetings/1`, which says "Hello, Bob!"

The [map](/cli/builtins.html#map) function is a built-in Origami function that applies a one-to-one map function to a graph of values. The result is a new, virtual graph of transformed values.

In this case, the `=greet(name)` part of the above formula defines an unnamed function (in technical jargon, a lambda expression) that's evaluated in the context of each individual person record. This extracts a person's name and passes it to the `greet` function.

Applying this `map` to the graph of people in `team.yaml` produces a new graph of greetings:

<div class="sideBySide">
  <figure>
    {{ svg team.yaml }}
  </figure>
  <figure>
    {{ svg greetings }}
  </figure>
  <figcaption>Source graph of real data</figcaption>
  <figcaption>Result graph of virtual greetings</figcaption>
</div>

When you want to do work on multiple files or data values in the Origami framework, it's generally helpful to think about how you can best represent the source information as a graph, then identify the transformation you want to apply to each value in the graph. This will produce a new virtual graph of results.

Some notes on the `map` function:

- Virtual graphs produced by `map` and the other Origami functions are _lazy_. They only do work when they need to. Unlike a JavaScript [Array map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), the `map` function here doesn't do much work upon invocation — it only does the real work of transformation when someone asks a mapped value. In this case, the greeting for a person like Carol is only generated when you actually try to visit that URL. The `greetings` graph represents _potential_ work.
- `map` only applies the mapping function to the top-level values of a graph. If you want to apply the mapping function to the deep values of a graph, use [mapDeep](/cli/builtins.html#mapDeep) instead to obtain a new, deep graph of transformed values.

Using formulas like this, you can begin transforming your `team.yaml` data into an About Us site.

## Transform a graph's keys

In the example above, `map` transforms the graph values but leaves the keys (the arrow labels) unchanged.

In the `greetings` graph shown above, the keys (labels) for the arrows are the array indices: 0, 1, 2. But in your About Us site, you want the route for a person's page to incorporate their name. To accomplish that, you can use another type of map called [mapKeys](/cli/builtins.html#mapKeys), which changes a graph's keys.

<span class="tutorialStep"></span> In the `+.yaml` file, add the following line:

```yaml
teamByName = mapKeys(team.yaml, =name):
```

In this case, the `=name` expression will evaluated in the context of an individual person, and will return that person's `name` property.

This `mapKeys` formula will result in a new graph using names as keys.

<div class="sideBySide">
  <figure>
    {{ svg team.yaml }}
  </figure>
  <figure>
    {{ svg teamByName }}
  </figure>
  <figcaption>team.yaml: array indices as top-level keys</figcaption>
  <figcaption>teamByName: names as top-level keys</figcaption>
</div>

## Apply multiple transformations

<span class="tutorialStep"></span> Update the `greeting` formula so that, instead of directly referencing `team.yaml`, it refers to `teamByName`:

```yaml
greetings = map(teamByName, =greet(name)):
```

Although the order of definitions in the `+.yaml` file doesn't matter, you might find it helpful to define `teamByName` first to reflect the logical progression:

```yaml
teamByName = mapKeys(team.yaml, =name):
greetings = map(teamByName, =greet(name)):
```

This shows the transformation of `team.yaml` in two steps: 1) transform the integer keys to name keys, 2) transform the person data values into greeting values.

<div class="sideBySide">
  <figure>
    {{ svg team.yaml }}
  </figure>
  <figure>
    {{ svg teamByName }}
  </figure>
  <figure>
    {{ svg greetingsByName }}
  </figure>
  <figcaption>team.yaml: source data</figcaption>
  <figcaption>teamByName: transformed keys</figcaption>
  <figcaption>greetings: transformed values</figcaption>
</div>

<span class="tutorialStep"></span> In the served site, inspect the intermediate `teamByName` graph as well as the final `greetings` graph.

Being able to explore intermediate structures like `teamByName` is a valuable debugging facility of the Origami framework. Normally you can only view such intermediate representations by setting debugger breakpoints and inspecting variable values in a properties panel. That is often cumbersome for complex data structures.

You've now roughed in the basic structure of the `team` route for the About Us site. The next step is to show something more interesting for a person than a simple greeting.

## Transform data into HTML with a template

You can transform data into HTML with plain JavaScript, but a template language can be more appropriate for that task.

You can use any template system with Origami, but for this tutorial you'll use the template system built into Origami. These Origami templates reuse the same expression language as Origami formulas and the ori command-line interface.

<span class="tutorialStep"></span> In the `src` folder, create a file called `person.ori` and type or copy/paste the following HTML:

```hbs
{{ intro/person.ori }}
```

Like most template languages, Origami templates let you mix boilerplate text with dynamic content represented with placeholders. In Origami templates, placeholders are delineated with curly braces. Inside the curly braces, you can put any expression in the Origami language, including graph paths and function calls.

Here, the `\{\{name}}` placeholder indicates that you'd like to evaluate the expression `name` in the context of the data for a single person to produce the text that should be shown.

## Apply a template as a function

A template is essentially a function for turning data into a text format like HTML, so Origami allows you to invoke a template as a function.

<span class="tutorialStep"></span> Add the following line to `+.yaml`. (If you entered more interesting names than what's shown here, then in both places below, substitute a name from your team file for "Alice".)

```yaml
Alice.html = person.ori(teamByName/Alice):
```

This formula creates a virtual file called `Alice.html`. The virtual file contains the HTML obtained by applying the `person.ori` template to the data for Alice in `team.yaml`:

```html
{{ intro/person.ori(teamByName/Alice) }}
```

<span class="tutorialStep"></span> Open `Alice.html` in the served site to view the result: Hello, **Alice**.

At this point, you're successfully transforming the data for a single person, Alice, to create a single web page for that person.

## Transform a data graph into HTML pages

Earlier you created a `greetings` graph that mapped the team members to a graph of greetings using a JavaScript function. You can also map the team members to HTML pages using your `person.ori` template.

<span class="tutorialStep"></span> Add the following line to `+.yaml`:

```yaml
team = map(teamByName, person.ori):
```

<span class="tutorialStep"></span> Visit the `team` route in the served site, and select a person's name to see a rudimentary HTML page for that person.

You have transformed the people data into HTML.

<div class="sideBySide">
  <figure>
    {{ svg teamByName }}
  </figure>
  <figure>
    {{ svg team }}
  </figure>
  <figcaption>Graph of people by name…</figcaption>
  <figcaption>…maps to HTML pages for each person</figcaption>
</div>

## Flesh out the person template

Let's make the `person.ori` template a bit more realistic. The project's `assets` folder contains a fuller `person.ori` template with some more elements:

```html
{{ intro/person2.ori }}
```

<span class="tutorialStep"></span> Move or copy that `person.ori` template from the `assets` folder to the `src` folder.

<span class="tutorialStep"></span> Also move or copy the `styles.css` and `personIcon.svg` files referenced by the updated template.

When you view the pages in the `team` route now, you should see a somewhat more presentable web page. The page contains a missing image that you'll fix in just a minute.

## Add an HTML extension

We often use extensions at the end of file names to indicate the type of data they contain. Graph transformations will often want to change these extensions to reflect a change in the type of data. For this reason, functions like `map` allow you to add, change, or remove extensions.

In this case, you want to map a person object with a key like `Alice` to an HTML file name like `Alice.html` to reflect the fact that that transformed graph value contains HTML.

<span class="tutorialStep"></span> Update the line for `team` so that it reads:

```yaml
team = map(teamByName, person.ori, '', '.html'):
```

The empty third parameter (`''`) indicates that you don't want to _remove_ anything from the graph keys, because they don't have any extension. The fourth parameter (`'.html'`) indicates that you want to _add_ `.html` to the graph keys. The transformation now looks like:

<div class="sideBySide">
  <figure>
    {{ svg teamByName }}
  </figure>
  <figure>
    {{ svg team2 }}
  </figure>
  <figcaption>Graph of people by name…</figcaption>
  <figcaption>…maps to a .html file for each person</figcaption>
</div>

<span class="tutorialStep"></span> Observe that the pages in the `team` route now end in `.html`.

## Bonus: Add avatars

A typical About Us area like our [example](/samples/aboutUs) shows headshot photographs for each team member. If you have pictures you'd like to use, you could use those here.

But for the sake of simplicity, you can use programmatically generated avatar images from a service like [DiceBear Avatars](https://avatars.dicebear.com/). Given an arbitrary string (like a name), that service always returns the same generated image.

<span class="tutorialStep"></span> From the `assets` folder, move or copy the `avatar.js` file to the `src` folder.

This file contains a function that maps an input string and returns a SVG file from the random avatar service.

```\js
{{ intro/avatar.js }}
```

It's not important to understand this JavaScript, only to recognize that it can do whatever it needs to do to obtain a resource from the web.

With that, you can map the `teamByName` graph to create a corresponding virtual folder of avatars.

<span class="tutorialStep"></span> Add the following line to `+.yaml`:

```yaml
avatars = map(teamByName, =avatar(name), '', '.svg'):
```

You should now be able to see avatars for the people on their HTML pages.

<span class="tutorialStep"></span> In the served site, navigate to the `src/avatars` folder to see a virtual folder of the generated avatar images.

This virtual `src/avatars` folder looks indistinguishable from a real folder of real images. As noted earlier, an important property of building content with Origami is that intermediate results are explorable in the browser (or from the command line).

Another common feature of working with Origami is that you can smoothly move between using real and virtual files. You could use these generated avatar SVGs to get started. Later, you could delete the `avatars` formula and create a real `avatars` folder containing manually-curated images or headshot photos.

With the addition of the avatars, you've completed the essential functions of the `team` route within the About Us area of the site you're designing. You could add more data fields to `team.yaml` and render those in the `person.ori` template, but from a functional standpoint, you're done with that part of the task.
