---
title: Built-In Functions
files = client/samples/cli.yaml:
---

These examples generally demonstrate invoking built-in functions from the command line. The same functions can also be used in Origami formulas in the Origami [framework](/framework).

<a name="@"></a>

## @

The built-in called `@` is a graph of the complete set of built-in functions. This allows you to disambiguate between a local file or function and a built-in of the same name.

For example, if your project contains a folder called `map`, then using `map` in a local formula will reference the local folder instead of the `map()` built-in. To reference the built-in `map`, you can write `@/map`.

<a name="assert"></a>

## assert([graph])

Treats the graph as an object with a `description`, `expected`, and `actual` keys. The graph is converted to a [metagraph](/framework/metagraph.html) if it is not already one so that a formula can be used to calculate the value of `actual`.

The result of `assert()` will be the result of the comparing `expected` and `actual` with Node's [deepStrictEqual](https://nodejs.org/api/assert.html#assertdeepstrictequalactual-expected-message) test.

If the assertion fails, `assert()` returns the `description`, `expected`, and evaluated `actual` values. Example:

```console
$ cat test.yaml
description: repeat built-in function can replicate a value
expected: beepbeep
actual = repeat(2, 'beep'):
$ ori assert test.yaml
description: repeat built-in function can replicate a value
expected: beepbeep
actual:
  - beep
  - beep
```

This assertion fails because [`repeat()`](#repeat) doesn't return a string; it returns an array. If this test is rewritten and re-run, the test passes and `assert()` generates no output.

```console
$ cat test.yaml
description: repeat built-in function can replicate a value
expected:
  - beep
  - beep
$ ori assert test.yaml
$
```

<a name="basename"></a>

## basename(path, [extension])

Returns the last file name in a path. If an `extension` is provided, it is removed from the file name.

Example: `basename('/src/index.html', '.html')` returns `index`.

<a name="cache"></a>

## cache(graph, [cache], [filter])

Caches values from `graph`. If a `cache` is provided, the cached values will be stored in that graph; if no `cache` is provided, the values will be stored in an in-memory graph.

If a `filter` is provided, only keys matching the filter will have their values cached.

<a name="clean"></a>

## clean()

Resets a project to the state it had prior to invoking [`make()`](#make). This removes any previous files generated by `make()` and deletes the hidden `ori.clean.yaml` file.

<a name="concat"></a>

## concat(...objs)

Converts the indicated objects to strings, then returns the concatenated strings.

- If an object is a function, it is invoked, then these rules are applied to the result.
- If an object is a graph, this concatenates the deep values in the graph.
- If an object can be converted to a string, it is. Otherwise, the empty string is used.

To concatenate two strings:

```console
$ ori "concat 'foo', 'bar'"
foobar
```

To concatenate the values in a graph:

```console
$ cat greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori concat greetings.yaml
Hello, Alice.Hello, Bob.Hello, Carol.
```

<a name="copy"></a>

## copy(sourceGraph, targetGraph)

Traverses the `sourceGraph` and writes all values into the `targetGraph`.

For example, to copy the values from a YAML file into individual files:

```console
$ cat greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori copy greetings.yaml, files/greetings
$ ls greetings
Alice   Bob     Carol
$ cat greetings/Alice
Hello, Alice.
```

The `files/greetings` argument indicates that `copy` should copy the input YAML graph to a file system graph under a folder named `greetings`. As a result, the key/value pairs in the YAML file are now individual files in a `greetings` folder.

The `targetGraph` must support the [`set`](/core/set.html) method. The only types of graphs defined in the ExplorableGraph [core library](/core) that provides such support are [ObjectGraph](/core/ObjectGraph.html) and [FilesGraph](/core/FilesGraph.html). Only the latter provides persistent effects, so `copy` is typically used to copy the values from the source graph into file system files.

<a name="dataflow"></a>

## dataflow(graph)

This returns an analysis of the data flow in the given graph. For a visual depiction of the data flow, use [flowSvg()](#flowSvg).

<a name="defaultGraph"></a>

## defaultGraph()

Returns the default graph that will be used by ori as the scope for evaluating commands. This will be an instance of [FilesGraph](/core/FilesGraph.html) for the current folder.

The graph will transformed in various ways to facilitate commands. Among other things, if the resulting graph is asked for a key like `foo` which does not exist, the graph will make a second check to see if a module `foo.js` exists and, if so, to return the default export from that module.

<a name="defaultPages"></a>

## defaultPages(graph)

Adds a default `index.html` and some diagnostic pages to the graph:

| Key        | Value                                                                                                                                                                                    |
| :--------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| .dataflow  | A visual dataflow for the current graph via [dataflow()](#dataflow) and [flowSvg()](#flowSvg)                                                                                            |
| .index     | A default index page that lets you view the content of a graph that also defines an `index.html` page.                                                                                   |
| .keys.json | The keys of the current graph in JSON format; intended to support programmatic explorability of a deployed site via [SiteGraph](https://graphorigami.org/core/sitegraph#keysjson-files). |
| .scope     | A page that lets you explore the scope of the current graph                                                                                                                              |
| .svg       | A visual rendering of the current graph via [svg()](#svg)                                                                                                                                |
| .yaml      | A YAML rendering of the current graph via [yaml()](#yaml)                                                                                                                                |
| index.html | A default index page for the current graph                                                                                                                                               |

<a name="dot"></a>

## dot(graph)

Returns a text representation of the indicated graph in the [DOT](https://graphviz.org/documentation/) graph description language. Various tools exist to render such a DOT representation into various graph formats such as PNG or SVG.

If you want a basic visual representation of a graph, use the [svg()](#svg) function instead. Use the `dot` function only if you want to use other DOT tools to render a graph.

<a name="expand"></a>

## expand(graph)

Expands [graph variant](/core/variants.html) values (e.g., YAML/JSON text) into graphs.

<a name="false"></a>

## false

This built-in is the JavaScript `false` value, and exists so you can pass `false` to functions.

<a name="feedRss"></a>

## feedRss(graph)

Converts a graph of posts in [JSON Feed](https://www.jsonfeed.org/) format to [RSS](https://www.rssboard.org/rss-specification) format. The graph can be any [graph variant](/core/variants.html).

<a name="fetch"></a>

## fetch(url)

Returns a [Buffer](https://nodejs.org/api/buffer.html) of the web resource at `url`.

<a name="files"></a>

## files([dirname])

Returns an [FilesGraph](/core/FilesGraph.html) representation of the current directory or (if `dirname` is supplied) subdirectory named `dirname` within the current directory.

<a name="filter"></a>

## filter(graph, filter)

Both arguments can be any [graph variant](/core/variants.html). This returns the values in the `graph` argument whose keys appear in the `filter` argument. This includes keys that appear in `filter` but not in `graph`, as long as the `graph` has a defined value for that key.

<a name="first"></a>

## first(graph)

Returns the first value in `graph`.

<a name="flowSvg"></a>

## flowSvg(graph)

Renders the dataflow output of [dataflow()](#dataflow) as an SVG image.

<a name="front"></a>

## front(text)

Returns any _front matter_ parsed from the start of the indicated text. The front matter data should be in JSON or YAML format and delimited before and after by three hyphens on a line by themselves.

```console assert: true, path: files
$ ori hello.md
---
title: Hello
---

Hello, world.
$ ori front hello.md
title: Hello
```

If the indicated text includes no front matter, this returns `undefined`.

<a name="globs"></a>

## globs(graph)

Treats the keys of `graph` as simple [glob](<https://en.m.wikipedia.org/wiki/Glob_(programming)>) patterns. The following patterns are supported:

- `*` matches anything
- `?` matches a single character

```console
$ cat globs.yaml
{{ client/samples/help/globs.yaml }}
$ ori "globs(globs.yaml)/foo.jpg"
false
$ ori "globs(globs.yaml)/foo.txt"
true
```

This can be used, for example, in conjunction with [`filter`](#filter) to filter values based on glob patterns.

<a name="graph"></a>

## graph(variant)

Converts any [graph variant](/core/variants.html) into an explorable graph.

<a name="graphVirtual"></a>

## graphVirtual(graph)

Wraps any [graph variant](/core/variants.html) as a virtual application using the Origami [framework](/framework). This will include the same [MetaTransform](/framework/MetaTransform.html) used by the [meta](#meta) function, as well as adding default pages like `index.html` via [DefaultPages](/framework/DefaultPages.html).

<a name="help"></a>

## help([name])

Displays this page, showing the documentation for the built-in function with the indicated name.

<a name="http"></a>

## http(domain, ...keys)

Returns an [ExplorableSite](/core/ExplorableSite.html) for the given HTTP URL. See also [https](#https) for details on arguments.

<a name="https"></a>

## https(domain, ...keys)

Returns an [ExplorableSite](/core/ExplorableSite.html) for the given HTTPS URL.

The first argument is a string indicating the URL domain; the remainder are the portions of the URL path within that domain. E.g., for the URL `example.com/foo/bar`, the arguments would be `example.com`, `foo`, and `bar`.

You normally won't need to call this function directly. ori will parse the URL `https://example.com/foo/bar` into the function call `https('example.com', 'foo', 'bar')` for you, so you can use the more readable URL format.

<a name="if"></a>

## if(condition, trueValue, [falseValue])

Evaluates `condition`, and if it is truthy, returns `trueValue`. If the condition is not truthy, this returns `falseValue` if supplied, otherwise `undefined`.

If `trueValue` or `falseValue` is a function, it will be evaluated and its result returned instead.

See also [unless()](#unless).

<a name="image"></a>

## image

This returns a set of functions for working with images. These make use of the [sharp](https://sharp.pixelplumbing.com/) library.

See below for the specific `image` functions, accessed via `image/`.

### image/format(buffer, format, [options])

Returns the image represented by `buffer` in a new image format. The `format` must be one of the following strings:

- `avif`
- `gif`
- `heif`
- `jp2`
- `jpeg`
- `jxl`
- `png`
- `raw`
- `tiff`
- `tile`
- `webp`

The [options](https://sharp.pixelplumbing.com/api-output#toformat) dictionary is passed to sharp's `toFormat()` function.

### image/resize(buffer, options)

Returns a new image, resizing the image represented by `buffer`. The [options](https://sharp.pixelplumbing.com/api-resize) should include a `height` and/or `width` property.

<a name="inline"></a>

## inline(text)

Invokes any Origami expressions found inside `{{`…`}}` placeholders in the `text`. This operation preserves any front matter in the document.

```console
$ cat inline.yaml
---
name: world
---
Hello, \{\{ name }}!
$ ori inline inline.yaml
---
name: world
---
Hello, world!
```

Among other things, you can use `inline` to incorporate one document inside another. For example, you can incorporate an HTML fragment in one document into an HTML defined in another document.

```console
$ cat page.html
<html>
  <body>
\{\{ fragment.html }}
  </body>
</html>
$ cat fragment.html
    <p>Hello, world.</p>
$ ori inline page.html
<html>
  <body>
    <p>Hello, world.</p>
  </body>
</html>
```

<a name="inherited"></a>

## inherited(key)

Gets the value of `key` which the graph inherits from its [scope](/language/scope.html), bypassing any value the graph itself may have for `key`.

<a name="inners"></a>

## inners(graph)

Returns the inner nodes — the nodes with children — in the indicated `graph`.

<a name="json"></a>

## json(object)

Render the contents of the object in JSON format.

The ori tool uses YAML as its default output format, so you can use the `json` command to reformat the output as JSON:

```console assert: true, path: files
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori json greetings.yaml
{
  "Alice": "Hello, Alice.",
  "Bob": "Hello, Bob.",
  "Carol": "Hello, Carol."
}
```

<a name="keys"></a>

## keys([graph])

Returns an array of the top-level keys in the indicated graph, which can be any [graph variant](/core/variants.html).

```console assert: true, path: files
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori keys greetings.yaml
- Alice
- Bob
- Carol
```

See also [values](#values).

<a name="make"></a>

## make([graph])

Performs an in-place build of a graph.
The `graph` must support the [`set`](/core/set.html) method, so `make()` is typically used with a [FilesGraph](/core/FilesGraph.html) instance.

The make operation compares the real values in the indicated `graph` with its virtual values implied by formulas. It then saves the virtual values as real values (i.e., as a real files).

A hidden file called `ori.clean.yaml` is used to record which virtual values were generated so that subsequent make operations can distinguish previous make output. To remove this file, use [`clean()`](#clean).

<a name="map"></a>

## map(graph, mapFn, [options])

Like [mapDeep](#mapDeep), but only transforms the top-level values of a graph. Any values which are subgraphs will be handed to the `mapFn` mapping function as is.

<a name="mapDeep"></a>

## mapDeep(graph, mapFn, [options])

Returns a new [MapValuesGraph](/core/MapValuesGraph.html) that applies the given `mapFn` to the deep values in the `graph`.

```console assert: true, path: files
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori uppercase.js
export default (x) => x.toString().toUpperCase();
$ ori "map(greetings.yaml, uppercase)"
Alice: HELLO, ALICE.
Bob: HELLO, BOB.
Carol: HELLO, CAROL.
```

If a `sourceExtension` or `targetExtension` are supplied, this returns a [MapTypesGraph](/core/MapTypesGraph.html) instead, which will only apply the `mapFn` to values whose keys end in the indicated `sourceExtension`. In that case, the mapped `asyncIterator` will change the key's extension to the indicated `targetExtension`.

Unlike a JavaScript [Array map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), the `map` function does not do any mapping work upon invocation — it only does the work when someone requests the mapped graph's keys or values.

The `mapFn` mapping function is typically a JavaScript function, but can be any [graph variant](/core/variants.html). For example, you can use a second [graph as a map](/cli/intro.html#use-a-graph-as-a-map).

`map` works on all levels of a graph. If you only want to transform the top-level values in a graph, see [map](#map).

<a name="mapKeys"></a>

## mapKeys(graph, [keyFn])

Returns a new graph that replaces the original keys with mapped keys, obtained by invoking the `keyFn` function for each value in the original graph. If the `keyFn` is omitted, the value itself becomes its own key.

```console assert: true, path: files
$ ori team.yaml
- name: Alice
- name: Bob
- name: Carol
$ ori mapKeys team.yaml, =name
Alice:
  name: Alice
Bob:
  name: Bob
Carol:
  name: Carol
```

<a name="match"></a>

## match(pattern, fn, [keys])

Returns a graph that can match against simple patterns or JavaScript regular expressions. This is useful in creating virtual graphs. For example, if you are creating a `/user` area within a site that will handle routes like `/user/[name].html`, you can use `match()` to match that pattern and return a result.

```console
$ ori "(match '[name].txt', =\`Hello, {{ name }}.\`)/Alice.txt"
Hello, Alice.
```

The expression in parentheses defines a `match()` graph that will match patterns of the form `[name].txt`. This graph is then used to obtain a value for the key `Alice.txt`. Since that matches, the `match()` generates a result — here, using a template.

The `pattern` argument can take one of two forms:

1. A simple pattern like `[name].txt`. When used to match `Alice.txt`, this puts "Alice" in scope as the value of `name`.
2. A JavaScript regular expression. One way to create a regular expression is with [RegExp()](#RegExp). If the regular expression matches, the value of any groups named in the regular expression will be put in scope.

By default, the graph will have no public keys, but you can provide any [graph variant](/core/variants.html) as the `keys` argument. That graph's keys will be used as the keys for the graph returned by `match()`.

<a name="mdHtml"></a>

## mdHtml(markdown)

Formats the indicated [markdown](https://github.github.com/gfm/) (GitHub-flavored) to HTML.

Any front matter in the markdown will be preserved at the top of the HTML output.

<a name="merge"></a>

## merge(...graphs)

Returns a graph that is the result of merging the indicated graphs. The graphs can be any [graph variant](/core/variants.html).

```console
$ cat graph1.yaml
a: The letter A
b: The letter B
c: The letter C
$ cat graph2.yaml
c: This won't appear in the merge
d: The letter D
e: The letter E
$ ori merge graph1.yaml, graph2.yaml
a: The letter A
b: The letter B
c: The letter C
d: The letter D
e: The letter E
```

When asked for a key, the merged graph asks each of the constituent graphs in turn for that key; the first defined result is returned. In the example above, getting `c` returns the result from `graph1.yaml`, because that is the first graph that defines a value for `c`.

The merge operation is shallow; for a deep merge operation, see [mergeDeep()](#mergeDeep).

<a name="mergeDeep"></a>

## mergeDeep(...graphs)

Like [merge()](#merge), but performs a deep merge: if multiple graphs define values for the same key, and those values are themselves explorable graphs, then those values themselves will be merged.

<a name="meta"></a>

## meta(graph)

Returns an Origami [metagraph](/framework/metagraph.html) by applying a [MetaTransform](/framework/MetaTransform.html) to the indicated graph. This interprets [formulas](/framework/formulas.html) in the graph's keys as ori expressions.

<a name="nextKey"></a>

## nextKey(graph, key)

Enumerates the graph's key until `key` is found, then returns the next key in the graph.

<a name="not"></a>

## not(obj)

Returns the logical truthy/falsy inverse of the given object.

<a name="nulls"></a>

## nulls(graph)

Returns a new graph with all values equal to null.

```console assert: true, path: files
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori nulls greetings.yaml
? Alice
? Bob
? Carol
```

`nulls` can be useful when you want to display the structure of a graph (especially a hierarchical graph) without concern for the actual data values.

<a name="ori"></a>

## ori(text)

Evaluates the string `text` as an Origami expression and returns the result.

<a name="orit"></a>

## orit(template, input, [options])

Evaluates the given `template` as an Origami template, passing in the given `input` object as template input.

Available `options`:

- `preserveFrontMatter`: if `true`, the output will include any front matter found in the `template`. The default is `false`.

<a name="parent"></a>

## parent(graph)

If the graph has a `parent` property, this returns the value of that property.

<a name="parse"></a>

## parseYaml(text)

Parses the indicated text as JSON or YAML. The parsed plain JavaScript object is returned or, if the parse fails, this returns `undefined`. This can be used to parse JSON or YAML files.

Parsing a quoted argument on the command line:

```console assert: true, path: files
$ ori parseYaml "'[1, 2, 3]'"
- 1
- 2
- 3
```

This is similar to the separate [plain](#plain) function, which can only parse JSON/YAML representing graphs. In contrast, the `parseYaml` function can handle text representing things that aren't graphs, such as arrays, dates, and numbers.

<a name="perf"></a>

## perf(obj)

Displays performance counters for various Origami operations used during the computation of `obj`.

<a name="plain"></a>

## plain([graph])

Converts an asynchronous explorable graph into a synchronous plain JavaScript object. The supplied argument can be any [graph variant](/core/variants.html) such as a JSON/YAML file, file system folder, etc. If omitted, `plain` converts the current graph — in the command line, this will be the current folder — to a plain JavaScript object.

A common use for `plain` is to convert a graph into a form that you can pass to any function that works with plain JavaScript objects.

<a name="previousKey"></a>

## previousKey(graph, key)

Enumerates the graph's key until `key` is found, then returns the previous key in the graph.

<a name="reals"></a>

## reals(graph)

Returns a graph of only the real values in the given [graph variant](/core/variants.html), omitting any virtual values implied by formulas.

```console
$ cat reals.yaml
greeting: Hello
message = greeting:
$ ori meta reals.yaml
greeting: Hello
message: Hello
$ ori reals meta reals.yaml
greeting: Hello
message = greeting: null
```

Here, the [meta()](#meta) interpretation of the sample graph returns one real value and one virtual value implied by a formula; the underlying formula key itself is hidden. The `reals()` function undoes this interpretation, ignoring the virtual value and recovering the otherwise hidden formula.

<a name="RegExp"></a>

## RegExp(string)

Creates and returns a JavaScript regular expression from the given string.

<a name="repeat"></a>

## repeat(count, obj)

Returns an array of size `count` filled with copies of the given `obj`.

```console
$ ori repeat 3, "'Hello'"
- Hello
- Hello
- Hello
```

<a name="reverse"></a>

## reverse(graph)

Reverses the order of keys in the given [graph variant](/core/variants.html).

```console
$ cat letters.yaml
a: The letter A
b: The letter B
c: The letter C
$ ori reverse letters.yaml
c: The letter C
b: The letter B
a: The letter A
```

<a name="scope"></a>

## scope([graph])

If the `graph` has a `scope` property, this returns the value of that property. An Origami [metagraph](/framework/metagraph.html) will have a `scope` property that returns a [Scope](/framework/scope.html) instance.

<a name="serve"></a>

## serve([graph], [port])

Starts a local web server to serve the contents of `graph`. To serve the current folder:

```console
$ ori serve .
Server running at http://localhost:5000
```

A web route like `a/b/c` will be turned into a graph traversal operation that returns the graph value at that path.

If no `graph` is supplied, `serve` uses the current graph (from the command line, that will be the current folder) transformed via the [app](#app) function into an application.

<a name="setDeep"></a>

## setDeep(target, source)

Recursively applies updates from the `source` graph to the `target` graph, both of which can be any [graph variant](/core/variants.html).

The `target` graph must support the [`set`](/core/set.html) method. The only types of graphs defined in the ExplorableGraph [core library](/core) that provides such support are [ObjectGraph](/core/ObjectGraph.html) and [FilesGraph](/core/FilesGraph.html).

<a name="setScope"></a>

## setScope(graph, ...scopeGraphs)

Returns a copy of the given `graph` with the indicated graphs as its scope.

<a name="site"></a>

## site(domain, [...keys])

Returns a new [SiteGraph](/core/SiteGraph.html) for the indicated `domain`. If `keys` are supplied, this traverses the keys and returns the resulting value.

The site must define [.keys.json](https://graphorigami.org/core/sitegraph#keysjson-files) files if the site graph is to be able to enumerate its contents. Regular web sites won't support that, but will at least allow values to be retrieved via the `get` method.

```console
$ ori site://graphorigami.org/samples/greetings/
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
```

<a name="shell"></a>

## shell(command)

Returns the output of executing the indicated shell command.

<a name="shuffle"></a>

## shuffle(graph)

Returns a new graph with the original `graph` keys randomly shuffled.

```console
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori shuffle greetings.yaml
Carol: Hello, Carol.
Alice: Hello, Alice.
Bob: Hello, Bob.
$ ori shuffle greetings.yaml
Carol: Hello, Carol.
Bob: Hello, Bob.
Alice: Hello, Alice.
```

<a name="sort"></a>

## sort(graph)

Returns a copy of the indicated [graph variant](/core/variants.html) with the keys sorted. The sort is performed with the default lexicograph Unicode sort order provided by JavaScript's [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) method.

```console
$ cat capitals.yaml
Japan: Tokyo
Turkey: Ankara
Australia: Canberra
Spain: Madrid
$ ori sort capitals.yaml
Australia: Canberra
Japan: Tokyo
Spain: Madrid
Turkey: Ankara
```

See also [sortBy()](#sortBy).

<a name="sortBy"></a>

## sortBy(graph, expression)

Like [sort()](#sort) above, but evaluates the indicated `expression` to determine the sort key. The sort key must support comparison via the JavaScript `<` (less than) and `>` (greater than) operators.

```console
$ cat capitals.yaml
Japan: Tokyo
Turkey: Ankara
Australia: Canberra
Spain: Madrid
$ ori sortBy capitals.yaml, =@value
Turkey: Ankara
Australia: Canberra
Spain: Madrid
Japan: Tokyo
```

<a name="static"></a>

## static(graph)

This adds keys to the graph which are commonly used when deploying a static web site:

- `index.html`
- `.keys.json` (see details on [.keys.json](https://graphorigami.org/core/sitegraph#keysjson-files) files)

<a name="stdin"></a>

## stdin()

Returns the complete contents of the standard input stream. This lets you pipe data into JavaScript functions:

```console
$ ori uppercase.js
export default (x) => x.toString().toUpperCase();
$ echo This is input from the shell | ori uppercase stdin
THIS IS INPUT FROM THE SHELL
```

<a name="stdout"></a>

## stdout(obj)

Writes the indicated object `obj` to the standard output stream. This `stdout` function is used by ori itself to write the evaluated result of an expression to the console. If you wish to override the standard `stdout` implementation to, say, default to JSON output instead of YAML, you can do so by defining your own function named `stdout` in the ori [config file](/cli/config.html).

<a name="string"></a>

## string(obj)

Returns the given object as text by invoking the object's JavaScript [toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) method.

<a name="svg"></a>

## svg(graph)

Returns a Scalable Vector Graphics [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG) text describing a two-dimensional visual representation of the indicated graph, which can be any [variant](/core/variants.html).

<a name="table"></a>

## table(graph)

Returns a basic tabular representation of the keys and values in the indicated `graph`.

If the graph is flat — that is, has only a single level of keys and values — the table will have two columns listing those.

```console
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori table greetings.yaml
Key     Value
Alice   Hello, Alice.
Bob     Hello, Bob.
Carol   Hello, Carol.
```

If the graph has two levels, the row headings will contain the top-level keys, and the column headings will be the second-level keys. (The first subgraph in the graph will be taken as representative of the remaining subgraphs.)

```console
$ ori languages.json
{
  "english": {
    "a": "Hello, a.",
    "b": "Hello, b.",
    "c": "Hello, c."
  },
  "french": {
    "a": "Bonjour, a.",
    "b": "Bonjour, b.",
    "c": "Bonjour, c."
  },
  "spanish": {
    "a": "Hola, a.",
    "b": "Hola, b.",
    "c": "Hola, c."
  }
}
$ ori table languages.json | column -t -s$'\\\t'
         a            b            c
english  Hello, a.    Hello, b.    Hello, c.
french   Bonjour, a.  Bonjour, b.  Bonjour, c.
spanish  Hola, a.     Hola, b.     Hola, c.
```

`table` separates columns with TAB characters. To ensure visual column alignment requires using other shell tools (such as [column](https://www.man7.org/linux/man-pages/man1/column.1.html), above).

<a name="take"></a>

## take(graph, n)

Returns a copy of the given [graph variant](/core/variants.html), with the additional restriction that the new graph's `asyncIterator` will return only (at most) the first `n` keys.

```console
$ cat letters.yaml
a: The letter A
b: The letter B
c: The letter C
$ ori take letters.yaml, 2
a: The letter A
b: The letter B
```

<a name="true"></a>

## true

This built-in is the JavaScript `true` value, and exists so you can pass `true` to functions.

<a name="unless"></a>

## unless(condition, falseValue)

Evaluates `condition`, and if it is falsy, returns `falseValue`. Otherwise this returns `undefined. This is essentially the logical inverse of [if()](#if).

If `falseValue` is a function, it will be evaluated and its result returned instead.

<a name="values"></a>

## values([graph])

Returns an array of the top-level values in the indicated graph, which can be any [graph variant](/core/variants.html).

```console assert: true, path: files
$ ori greetings.yaml
Alice: Hello, Alice.
Bob: Hello, Bob.
Carol: Hello, Carol.
$ ori values greetings.yaml
- Hello, Alice.
- Hello, Bob.
- Hello, Carol.
```

See also [keys](#keys).

<a name="valuesDeep"></a>

## valuesDeep(graph)

Return the in-order exterior values of the given [graph variant](/core/variants.html) as a flat array.

```console
$ cat greetings.yaml
english:
  a: Hello, a.
  b: Hello, b.
  c: Hello, c.
french:
  a: Bonjour, a.
  b: Bonjour, b.
  c: Bonjour, c.
spanish:
  a: Hola, a.
  b: Hola, b.
  c: Hola, c.
$ ori valuesDeep greetings.yaml
- Hello, a.
- Hello, b.
- Hello, c.
- Bonjour, a.
- Bonjour, b.
- Bonjour, c.
- Hola, a.
- Hola, b.
- Hola, c.
```

<a name="virtual"></a>

## virtual([key])

Returns the current graph as an explorable application. This creates an [FilesGraph](/core/FilesGraph.html) at the current graph or folder, then wraps that with a virtual app via [graphVirtual](#graphVirtual).

If a key is supplied, this gets the indicated key from the resulting explorable application.

## watch([graph], [expression])

Returns a graph that will be the result of executing the indicated `expression` in the context of the indicated `graph`.

This also watches the `graph` for `change` events. Currently, [FilesGraph](/core/FilesGraph.html) is the only type of graph that supports `change` events. If a `change` event is raised, the `expression` is reevaluated to obtain a new result graph. Subsequent references to the `watch()` result will access the new graph.

This can be used, for example, to serve a virtual folder, reevaluating the folder's definition whenever the containing real folder changes.

```console
$ ori serve src, =site.vfiles/public
```

<a name="yaml"></a>

## yaml(object)

Render the contents of the object in YAML format.

The ori tool uses YAML as its default output format, so you won't often need to invoke the `yaml` function yourself from the command line. One occasion to use it would be to convert a JSON file to YAML.

```console assert: true, path: files
$ ori letters.json
{
  "a": "The letter A",
  "b": "The letter B",
  "c": "The letter C"
}
$ ori yaml letters.json
a: The letter A
b: The letter B
c: The letter C
```
